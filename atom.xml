<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rosen</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rosen.xyz/"/>
  <updated>2016-07-15T11:58:01.338Z</updated>
  <id>http://rosen.xyz/</id>
  
  <author>
    <name>Rosen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 363</title>
    <link href="http://rosen.xyz/2016/07/15/LeetCode-363/"/>
    <id>http://rosen.xyz/2016/07/15/LeetCode-363/</id>
    <published>2016-07-15T09:10:27.000Z</published>
    <updated>2016-07-15T11:58:01.338Z</updated>
    
    <content type="html">&lt;h2 id=&quot;题目及分析&quot;&gt;&lt;a href=&quot;#题目及分析&quot; class=&quot;headerlink&quot; title=&quot;题目及分析&quot;&gt;&lt;/a&gt;题目及分析&lt;/h2&gt;&lt;p&gt;给一个非空r*c的矩阵（r&amp;gt;&amp;gt;c），找一个子矩阵使得该矩阵的和不超过给定的k（难度：hard）&lt;/p&gt;
&lt;p&gt;暴力方法： 枚举两个子矩阵的两个端点，复杂度O(rrcc)&lt;br&gt;这个问题是另外几个问题的叠加&lt;/p&gt;
&lt;h2 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink&quot; title=&quot;问题1&quot;&gt;&lt;/a&gt;问题1&lt;/h2&gt;&lt;p&gt;题意： 给定一个一维数组A，求解A中和最大的子序列&lt;br&gt;思路： 动态规划，d[i]表示以A[i]为结尾的和最大序列的和，那么以A[i+1]结尾和最大序列则为：如果d[i]&amp;gt;0,则序列接上A[i],否则A[i+1]自己为和最大序列。转移公式为：d[i+1] = d[i] &amp;gt; 0 ? d[i] + A[i+1], A[i+1]。时间复杂度为O(n)。&lt;/p&gt;
&lt;h2 id=&quot;问题2&quot;&gt;&lt;a href=&quot;#问题2&quot; class=&quot;headerlink&quot; title=&quot;问题2&quot;&gt;&lt;/a&gt;问题2&lt;/h2&gt;&lt;p&gt;题意： 求一个二维矩阵A的子矩阵，使得子矩阵的所有元素的和最大&lt;br&gt;思路： 扫描线，每次固定两列L、R，表示子矩阵的左右两端，对于每一行求出L~R列的和(使用累积和相减)，即可得到一个一维数组A[row],问题转换为即可转换为问题1。固定。时间复杂度为O(min(ccr,rrc))。&lt;/p&gt;
&lt;h2 id=&quot;问题3&quot;&gt;&lt;a href=&quot;#问题3&quot; class=&quot;headerlink&quot; title=&quot;问题3&quot;&gt;&lt;/a&gt;问题3&lt;/h2&gt;&lt;p&gt;题意： 给定一个一维数组A，求解A中和不超过k的最大子序列&lt;br&gt;思路： 预处理一个累加和数组C，C[i]表示从sum(A[0~i])，则sum(A[i~j]) = C[j] - C[i-1]，问题可表述为：找到一对i，j使得T = C[j] - C[i-1] &amp;lt;= k并且使T最大。 通过移项有： C[j] - k &amp;lt;= C[i-1], 问题转换为： 对与每个j，在集合S = {0, C[1], C[2], … C[j-1]}中求一个小于 C[j] - K的最大值，如果使用二叉搜索树维护S，则该问题的复杂度为O(lgj)。总体复杂度O(nlgn)。&lt;/p&gt;
&lt;h2 id=&quot;本题&quot;&gt;&lt;a href=&quot;#本题&quot; class=&quot;headerlink&quot; title=&quot;本题&quot;&gt;&lt;/a&gt;本题&lt;/h2&gt;&lt;p&gt;明白了以上问题的解法，本题将迎刃而解。&lt;br&gt;首先，使用扫描线法每次固定两列（r&amp;gt;&amp;gt;c）L、R，求出每一行L～R列的和得到一个一维数组A，使用问题3中的方法找出A中和小于但最接近k的子序列，总体时间复杂度为：O(ccrlgr)&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Solution &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxSumSubmatrix&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;gt;&amp;amp; matrix, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row = matrix.size(), col = matrix[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].size();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cum_matrix[row][col];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//预处理，对每行累积求和&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; row; i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; col; j++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(j == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)cum_matrix[i][j] = matrix[i][j];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; cum_matrix[i][j] = cum_matrix[i][j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] + matrix[i][j];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; max_sum = &lt;span class=&quot;number&quot;&gt;-0x7fffffff&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; cum_sum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//扫描线，固定两列，变成一个在以为数组中寻找最大不超过k的子序列&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; col; i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = i; j &amp;lt; col; j++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; f, tmp = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                cum_sum.clear();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 二分&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; s &amp;lt; row; s++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    cum_sum.insert(tmp);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) f = cum_matrix[s][j];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; f = cum_matrix[s][j] - cum_matrix[s][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    tmp += f;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//set本身有序，可使用STL中upper_bound函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator iter = cum_sum.upper_bound(tmp-k&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(iter != cum_sum.end())&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        max_sum = max(max_sum, tmp - *iter);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; max_sum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目及分析&quot;&gt;&lt;a href=&quot;#题目及分析&quot; class=&quot;headerlink&quot; title=&quot;题目及分析&quot;&gt;&lt;/a&gt;题目及分析&lt;/h2&gt;&lt;p&gt;给一个非空r*c的矩阵（r&amp;gt;&amp;gt;c），找一个子矩阵使得该矩阵的和不超过给定的k（难度：hard）&lt;/p&gt;

    
    </summary>
    
    
      <category term="动态规划" scheme="http://rosen.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="扫描线" scheme="http://rosen.xyz/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
      <category term="STL" scheme="http://rosen.xyz/tags/STL/"/>
    
      <category term="LeetCode" scheme="http://rosen.xyz/tags/LeetCode/"/>
    
      <category term="Hard" scheme="http://rosen.xyz/tags/Hard/"/>
    
      <category term="二分查找" scheme="http://rosen.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="算法" scheme="http://rosen.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>序</title>
    <link href="http://rosen.xyz/2016/07/14/%E5%BA%8F/"/>
    <id>http://rosen.xyz/2016/07/14/序/</id>
    <published>2016-07-14T11:21:28.000Z</published>
    <updated>2016-07-15T09:08:41.178Z</updated>
    
    <content type="html">&lt;p&gt;待写&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;待写&lt;/p&gt;

    
    </summary>
    
    
      <category term="感想" scheme="http://rosen.xyz/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
</feed>
